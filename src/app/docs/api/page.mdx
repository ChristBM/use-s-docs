# API Reference

The `useS` hook offers a powerful yet minimal API to manage both **local** and **global** state in React ‚Äî with built-in immutability and TypeScript support.

- State type is automatically inferred from the `initialValue`.
- Supported types: `null | undefined | number | string | boolean | bigint | function | date | regexp | array | set | map | object`.

---

## üß† `useS(initialValue: T)`

Creates a **local** state, just like `useState`, but with enhanced capabilities:

```ts copy /useS/ /number/ /initialValue/
const [state, setState] = useS(0);
```
---

## üåç `useS({ value: T, key: string })`

Creates a **global** state shared across all components using the same `key`.

```ts copy /value/ /key/
const [count, setCount] = useS({
  value: 0,
  key: "global-counter",
});
```

This is functionally identical to local state, but allows cross-component sharing.

### üîë Global State Rules

- `key` must be a **non-empty unique string**.
- The **first call** to `useS()` with a given key sets the **initial value**.
- All subsequent calls with the same key:
  - **Ignores** the creation of a new state.
  - Share the **same state**.
- This ensures state consistency without conflicts or duplication ‚Äî regardless of where or how many times the key is used.

---

## üß¨ Built-In Immutability

- **Immutability at entry**: useS does not work on the memory reference of the initialValue, it only clones it and creates the state.
- **Immutability at exit**: useS returns a clone of the actual state, which can be mutated from the component, and this mutation does not affect the original state.

With useS, you will always respect React's rule of not mutating state because it lets you do so without consequences and then allows you to use that mutation to update it with setState without risk:

---

```tsx copy showLineNumbers filename="Component.tsx" {1,7,8}
const initialValue = new Set([1, 2, 3, 4]);

export function Component() {
  const [mySet, setMySet] = useS(initialValue);

  const handleAddItem = () => {
    mySet.add(5); // mutating mySet state directly
    setMySet(mySet); // setting the mutated state to generate a valid change
  };

  return (
    <div>
      <p data-testid="display">Items:{Array.from(mySet).join("-")}</p>
      <button onClick={handleAddItem}>Add Item</button>
    </div>
  );
}

```

---

## üîç Intelligent Validation and Render Prevention

One of the most powerful optimizations in `useS` is its ability to **prevent unnecessary re-renders** through structural comparison between the previous and the next value.
This means that if the new value is **not different** or is **not supported**, the state will not be updated and the component will **not be re-rendered**.

### How Does It Work?

Internally, `useS` uses a comparison function based on the data type.
Each supported type has its own mechanism to determine whether a change is valid:

| Value Type         | Comparison Strategy                                            |
|--------------------|----------------------------------------------------------------|
| All                | `Object.is(a, b)`.                                                |
| `Date`             | Compares timestamps using `getTime()`.                         |
| `RegExp`           | Compares `source` and `flags`.                                 |
| `Set`              | Recursively compares each value.                               |
| `Map`              | Recursively compares each key and value.                       |
| `Array`            | Recursively compares each element.                             |
| `Object`           | Recursively compares keys and values, including nested ones.   |

This allows you to handle complex structures without external libs or manual hacks like `JSON.stringify`.

### ‚ö†Ô∏è Exceptions

- Functions:

Although you can include functions as part of your state these are **compared by reference**.
Every time a key is updated with a function value, it is likely to  **trigger a state update and re-render**.

This behavior is consistent with how React handles functions.

- Initialization values: `null | undefined | [] | {} | new Set() | new Map()`

The validation function recognizes the previous common initialization values, allowing them to be assigned to the state.
In addition, if the previous value is one of these, it allows the next value to be assigned to the state, checking that it is a compatible value.



---

## Summary

| Feature                          | Status      | Notes                                                                 |
|----------------------------------|-------------|-----------------------------------------------------------------------|
| Local state                      | ‚úÖ Complete | Same API as `useState`                                                |
| Global state                     | ‚úÖ Complete | Shared by `key`, no Provider required                                 |
| TypeScript support               | ‚úÖ Complete | Fully inferred, no manual typing needed                               |
| Automatic immutability           | ‚úÖ Complete | Deep cloning at the entrance and exit                                 |
| Avoid Unnecessary re-renders     | ‚úÖ Complete | Reference or deep value comparison with type validation               |
| Derived state support            | ‚úÖ Complete | Supports computed state via function properties                       |
| React 18 compatibility           | ‚úÖ Complete | Uses `useSyncExternalStore`                                           |
| Web & React Native               | ‚úÖ Complete | Compatible with both                                                  |
| Bundle size                      | ‚úÖ Small    | 22.9kB Unpacked Size                                                  |
| Boilerplate-free                 | ‚úÖ Complete | No context, no Provider, no setup                                     |
| DevTools/debugging               | ‚ö†Ô∏è Partial  | `debugGlobalStore()` available via console                            |
| Built-in persistence             | ‚ùå Not yet  | Planned for future versions                                           |

---

Ready to see it in action?
Explore real-world [Examples](/docs/examples) to see how `useS` can simplify your components.
